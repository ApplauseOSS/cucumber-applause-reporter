{"version":3,"file":"index.min.js","sources":["../src/hooks.ts","../src/index.ts"],"sourcesContent":["import { IWorld } from '@cucumber/cucumber';\n\nexport const APPLAUSE_SESSION_ID_ATTACHMENT = 'applause-session-id';\n\nexport function linkSessionId(this: IWorld<any>, sessionId: string) {\n  this.attach(sessionId, {\n    fileName: APPLAUSE_SESSION_ID_ATTACHMENT,\n    mediaType: 'text/plain',\n  });\n}\n","import { Formatter, IFormatterOptions } from '@cucumber/cucumber';\nimport {\n  ApplauseReporter,\n  TestRailOptions,\n  TestResultStatus,\n  loadConfig,\n} from 'applause-reporter-common';\nimport { EventEmitter } from 'events';\nimport {\n  Envelope,\n  Pickle,\n  PickleStep,\n  TestCase,\n  TestCaseFinished,\n  TestCaseStarted,\n  TestStep,\n  TestStepFinished,\n  TestStepResultStatus,\n} from '@cucumber/messages';\nimport { APPLAUSE_SESSION_ID_ATTACHMENT } from './hooks';\n\nexport default class CucumberAutoApiFormatter extends Formatter {\n  private reporter: ApplauseReporter;\n\n  // Maps used to handle data lookup between events.\n  // Test Case Storage Handles Storing Information about a TestCase by the TestCaseId\n  private testCaseStorage: Record<string, TestCase> = {};\n  // Test Case Instance Map Maps a TestCaseInstance Id (Single Execution of a TestCase) to the TestCaseId\n  private testCaseInstanceMap: Record<string, string> = {};\n  private testCaseInstanceSessionMap: Record<string, string[]> = {};\n  // Pickle Map Holds Information about the Gherkin TestCase Information (The actual written out test case)\n  private pickleMap: { [pickleId: string]: Pickle } = {};\n  // TestResult Status Map keeps track of the status for a TestCaseInstance. If a step fails, the test case fails\n  private testResultStatusMap: {\n    [testCaseInstanceId: string]: [TestResultStatus, string | undefined];\n  } = {};\n\n  private readonly REMOVE_CONTROL_CHARS: RegExp = new RegExp(\n    /* eslint-disable-next-line no-control-regex */\n    /[^\\x00-\\x7F]/gm\n  );\n  private readonly REMOVE_ANSI_CHARACTERS: RegExp = new RegExp(\n    /* eslint-disable-next-line no-control-regex */\n    [\n      '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n      '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n    ].join('|'),\n    'gm'\n  );\n\n  constructor(options: IFormatterOptions) {\n    super(options);\n    console.log('CDP is: ' + process.cwd());\n    const config = loadConfig({\n      configFile: 'applause.json',\n      properties: {\n        apiKey: <string>options.parsedArgvOptions['apiKey'],\n        baseUrl: <string>options.parsedArgvOptions['autoApiUrl'],\n        productId: <number>options.parsedArgvOptions['productId'],\n        testRailOptions: <TestRailOptions>(\n          options.parsedArgvOptions['testRailOptions']\n        ),\n        applauseTestCycleId: <number>(\n          options.parsedArgvOptions['applauseTestCycleId']\n        ),\n      },\n    });\n\n    // Setup our Http Client\n    this.reporter = new ApplauseReporter(config);\n\n    // Add in listener hooks\n    this.registerListeners(options.eventBroadcaster);\n  }\n\n  /**\n   * Registering an event listener to Cucumber's Messaging Api. Only one event will\n   * be contained in each envelope\n   *\n   * @param eventBroadcaster An Event Emitter\n   */\n  registerListeners(eventBroadcaster: EventEmitter): void {\n    eventBroadcaster.on('envelope', (envelope: Envelope) => {\n      if (envelope.gherkinDocument) {\n        envelope.gherkinDocument.feature?.children.map(\n          child => child.scenario?.name\n        );\n      }\n      if (envelope.testRunStarted) {\n        this.reporter.runnerStart(\n          Object.values(this.testCaseStorage).map(\n            testCase => this.pickleMap[testCase.pickleId].name\n          )\n        );\n      } else if (envelope.attachment) {\n        if (envelope.attachment.fileName == APPLAUSE_SESSION_ID_ATTACHMENT) {\n          const testCaseStartedId = envelope.attachment.testCaseStartedId;\n          if (testCaseStartedId === undefined) {\n            return;\n          }\n          const existingSessions =\n            this.testCaseInstanceSessionMap[testCaseStartedId] || [];\n          this.testCaseInstanceSessionMap[testCaseStartedId] = [\n            ...existingSessions,\n            envelope.attachment.body,\n          ];\n        }\n      } else if (envelope.testCase) {\n        this.testCaseStorage[envelope.testCase.id] = envelope.testCase;\n      } else if (envelope.pickle) {\n        this.pickleMap[envelope.pickle.id] = envelope.pickle;\n      } else if (envelope.testCaseStarted) {\n        this.onTestCaseStarted(envelope.testCaseStarted);\n      } else if (envelope.testStepFinished) {\n        this.onTestStepFinished(envelope.testStepFinished);\n      } else if (envelope.testCaseFinished) {\n        void this.onTestCaseFinished(envelope.testCaseFinished);\n      } else if (envelope.testRunFinished) {\n        void this.reporter.runnerEnd();\n      }\n    });\n  }\n\n  /**\n   * Hook called when a single instance of a test case is started. Used to register the start of a TestCase\n   *\n   * @param event The Test Case Started Event\n   */\n  onTestCaseStarted(event: TestCaseStarted): void {\n    this.testCaseInstanceMap[event.id] = event.testCaseId;\n    const testCase = this.testCaseStorage[event.testCaseId];\n    this.reporter.startTestCase(\n      testCase.id,\n      this.pickleMap[testCase.pickleId].name,\n      { providerSessionIds: this.testCaseInstanceSessionMap[event.id] || [] }\n    );\n    this.testResultStatusMap[event.id] = [TestResultStatus.PASSED, undefined];\n  }\n\n  /**\n   * Hook called when a TestStep is finished. Used to tell if and when a TestCase fails.\n   *\n   * @param event The Test Step Finished Event\n   */\n  onTestStepFinished(event: TestStepFinished): void {\n    // We already assume that the test case will pass, so if it did, just move on\n    if (event.testStepResult.status == TestStepResultStatus.PASSED) {\n      return;\n    }\n\n    const currentStatus = this.testResultStatusMap[event.testCaseStartedId][0];\n    // If the current result already has a status set, don't override it\n    if (currentStatus != TestResultStatus.PASSED) {\n      return;\n    }\n\n    // Get the test case ID\n    const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n\n    // Lookup the TestCase\n    const testCase = this.testCaseStorage[testCaseId];\n\n    // Look for the TestStep that was executed\n    const testStepOptions: TestStep[] = testCase.testSteps.filter(\n      s => s.id == event.testStepId\n    );\n    if (testStepOptions && testStepOptions.length != 1) {\n      throw new Error('Could not find test step within the test case');\n    }\n\n    // Now that we have the test step, lets look it up in the pickle to get the actual step text\n    const pickle: Pickle | undefined = this.pickleMap[testCase.pickleId];\n    const pickleStepId: string | undefined = testStepOptions[0].pickleStepId;\n    const pickleSteps: readonly PickleStep[] = pickle ? pickle.steps : [];\n    const pickleStep: PickleStep | undefined = pickleSteps.filter(\n      step => step.id == pickleStepId\n    )[0];\n\n    const stepText: string | undefined = pickleStep\n      ? pickleStep.text\n      : undefined;\n\n    // Map the step status to a result status\n    let status: TestResultStatus;\n    switch (event.testStepResult.status) {\n      case TestStepResultStatus.FAILED:\n        status = TestResultStatus.FAILED;\n        break;\n      case TestStepResultStatus.AMBIGUOUS:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.PENDING:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.SKIPPED:\n        status = TestResultStatus.SKIPPED;\n        break;\n      case TestStepResultStatus.UNDEFINED:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.UNKNOWN:\n        status = TestResultStatus.FAILED;\n        break;\n    }\n    const cucumberMessage = this.cleanCucumberMessage(\n      event.testStepResult.message || 'Unknown'\n    );\n    let errorMessage: string;\n    if (stepText != undefined) {\n      errorMessage = `${event.testStepResult.status} Test Step: ${stepText}. Reason: ${cucumberMessage}`;\n    } else {\n      errorMessage = `Test Case ${event.testStepResult.status} at Unknown Step. Reason: ${cucumberMessage}`;\n    }\n    // Finally, save off the updated statuses\n    this.testResultStatusMap[event.testCaseStartedId] = [status, errorMessage];\n  }\n\n  /**\n   * Hook called when a TestCase finishes it's execution. USed to submit test results to AutoApi\n   *\n   * @param event The TestCaseFinished event\n   */\n  onTestCaseFinished(event: TestCaseFinished): void {\n    // Pull the TestResults from the TestResultStatusMap\n    const [status, failure] = this.testResultStatusMap[event.testCaseStartedId];\n\n    const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n\n    // Finally, submit the TestResult\n    this.reporter.submitTestCaseResult(\n      testCaseId,\n      status || TestResultStatus.PASSED,\n      {\n        failureReason: failure,\n        providerSessionGuids:\n          this.testCaseInstanceSessionMap[event.testCaseStartedId] || [],\n      }\n    );\n  }\n\n  private cleanCucumberMessage(message: string): string {\n    return message\n      .replace(this.REMOVE_ANSI_CHARACTERS, '')\n      .replace(this.REMOVE_CONTROL_CHARS, '');\n  }\n}\n\nexport * from './hooks.ts';\n"],"names":["APPLAUSE_SESSION_ID_ATTACHMENT","CucumberAutoApiFormatter","Formatter","constructor","options","super","this","testCaseStorage","testCaseInstanceMap","testCaseInstanceSessionMap","pickleMap","testResultStatusMap","REMOVE_CONTROL_CHARS","RegExp","REMOVE_ANSI_CHARACTERS","join","console","log","process","cwd","config","loadConfig","configFile","properties","apiKey","parsedArgvOptions","baseUrl","productId","testRailOptions","applauseTestCycleId","reporter","ApplauseReporter","registerListeners","eventBroadcaster","on","envelope","gherkinDocument","feature","children","map","child","scenario","name","testRunStarted","runnerStart","Object","values","testCase","pickleId","attachment","fileName","testCaseStartedId","undefined","existingSessions","body","id","pickle","testCaseStarted","onTestCaseStarted","testStepFinished","onTestStepFinished","testCaseFinished","onTestCaseFinished","testRunFinished","runnerEnd","event","testCaseId","startTestCase","providerSessionIds","TestResultStatus","PASSED","testStepResult","status","TestStepResultStatus","testStepOptions","testSteps","filter","s","testStepId","length","Error","pickleStepId","pickleStep","steps","step","stepText","text","FAILED","AMBIGUOUS","PENDING","ERROR","SKIPPED","UNDEFINED","UNKNOWN","cucumberMessage","cleanCucumberMessage","message","errorMessage","failure","submitTestCaseResult","failureReason","providerSessionGuids","replace","sessionId","attach","mediaType"],"mappings":"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"}