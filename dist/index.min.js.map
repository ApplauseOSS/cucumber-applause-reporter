{"version":3,"file":"index.min.js","sources":["../src/reporter.ts"],"sourcesContent":["import { Formatter, IFormatterOptions } from '@cucumber/cucumber';\nimport { AutoApi, TestResultStatus } from 'applause-reporter-common';\nimport { EventEmitter } from 'events';\nimport {\n  Envelope,\n  Pickle,\n  PickleStep,\n  TestCase,\n  TestCaseFinished,\n  TestCaseStarted,\n  TestStep,\n  TestStepFinished,\n  TestStepResultStatus,\n} from '@cucumber/messages';\n\nexport default class CucumberAutoApiFormatter extends Formatter {\n  private autoApi: AutoApi;\n\n  // Custom Parameters\n  private productId: number;\n  private runName: string;\n\n  // Maps used to handle data lookup between events.\n  // Test Case Storage Handles Storing Information about a TestCase by the TestCaseId\n  private testCaseStorage: { [testCaseId: string]: TestCase } = {};\n  // Test Case Instance Map Maps a TestCaseInstance Id (Single Execution of a TestCase) to the TestCaseId\n  private testCaseInstanceMap: { [testCaseInstanceId: string]: string } = {};\n  // Test Instance ResultId Map Holds References to the TestResult creation promise\n  private testCaseInstanceResultIdMap: {\n    [testCaseInstanceId: string]: Promise<number>;\n  } = {};\n  // Pickle Map Holds Information about the Gherkin TestCase Information (The actual written out test case)\n  private pickleMap: { [pickleId: string]: Pickle } = {};\n  // TestResult Status Map keeps track of the status for a TestCaseInstance. If a step fails, the test case fails\n  private testResultStatusMap: {\n    [testCaseInstanceId: string]: [TestResultStatus, string | undefined];\n  } = {};\n\n  private readonly REMOVE_CONTROL_CHARS: RegExp = new RegExp(\n    /* eslint-disable-next-line no-control-regex */\n    /[^\\x00-\\x7F]/gm\n  );\n  private readonly REMOVE_ANSI_CHARACTERS: RegExp = new RegExp(\n    /* eslint-disable-next-line no-control-regex */\n    [\n      '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n      '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n    ].join('|'),\n    'gm'\n  );\n\n  constructor(options: IFormatterOptions) {\n    super(options);\n\n    // Extract out any arguments and handle validation\n    const apiKey = <string>options.parsedArgvOptions['apiKey'];\n    const autoApiUrl = <string>options.parsedArgvOptions['autoApiUrl'];\n    this.runName = <string>options.parsedArgvOptions['runName'];\n    this.productId = <number>options.parsedArgvOptions['productId'];\n    if (apiKey == undefined || apiKey.length <= 0) {\n      throw new Error('Invalid Api Key');\n    } else if (this.runName == undefined || this.runName.length <= 0) {\n      throw new Error('Invalid Run Name: ' + this.runName);\n    } else if (this.productId < 0) {\n      throw new Error(`Invalid Product Id: ${this.productId}`);\n    } else if (autoApiUrl == undefined || autoApiUrl.length <= 0) {\n      throw new Error('Invalid URL: ' + autoApiUrl);\n    }\n\n    // Setup our Http Client\n    this.autoApi = new AutoApi({\n      clientConfig: {\n        apiKey,\n        baseUrl: autoApiUrl,\n      },\n      productId: this.productId,\n      groupingName: this.runName,\n    });\n\n    // Add in listener hooks\n    this.registerListeners(options.eventBroadcaster);\n  }\n\n  /**\n   * Registering an event listener to Cucumber's Messaging Api. Only one event will\n   * be contained in each envelope\n   *\n   * @param eventBroadcaster An Event Emitter\n   */\n  registerListeners(eventBroadcaster: EventEmitter): void {\n    eventBroadcaster.on('envelope', (envelope: Envelope) => {\n      if (envelope.testCase) {\n        this.onTestCasePrepared(envelope.testCase);\n      } else if (envelope.pickle) {\n        this.pickleMap[envelope.pickle.id] = envelope.pickle;\n      } else if (envelope.testCaseStarted) {\n        this.onTestCaseStarted(envelope.testCaseStarted);\n      } else if (envelope.testStepFinished) {\n        this.onTestStepFinished(envelope.testStepFinished);\n      } else if (envelope.testCaseFinished) {\n        void this.onTestCaseFinished(envelope.testCaseFinished);\n      }\n    });\n  }\n\n  /**\n   * Hook called when a test case is parsed. Used for storing information about a TestCase\n   *\n   * @param event The Test Case Event\n   */\n  onTestCasePrepared(event: TestCase): void {\n    this.testCaseStorage[event.id] = event;\n  }\n\n  /**\n   * Hook called when a single instance of a test case is started. Used to register the start of a TestCase\n   *\n   * @param event The Test Case Started Event\n   */\n  onTestCaseStarted(event: TestCaseStarted): void {\n    this.testCaseInstanceMap[event.id] = event.testCaseId;\n    const testCase = this.testCaseStorage[event.testCaseId];\n    // These messages happen async from the execution of the test cases. That means that we need\n    this.testCaseInstanceResultIdMap[event.id] = this.autoApi\n      .startTestCase(this.pickleMap[testCase.pickleId].name)\n      .then(res => res.data.testResultId);\n    this.testResultStatusMap[event.id] = [TestResultStatus.PASSED, undefined];\n  }\n\n  /**\n   * Hook called when a TestStep is finished. Used to tell if and when a TestCase fails.\n   *\n   * @param event The Test Step Finished Event\n   */\n  onTestStepFinished(event: TestStepFinished): void {\n    // We already assume that the test case will pass, so if it did, just move on\n    if (event.testStepResult.status == TestStepResultStatus.PASSED) {\n      return;\n    }\n\n    const currentStatus = this.testResultStatusMap[event.testCaseStartedId][0];\n    // If the current result already has a status set, don't override it\n    if (currentStatus != TestResultStatus.PASSED) {\n      return;\n    }\n\n    // Get the test case ID\n    const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n\n    // Lookup the TestCase\n    const testCase = this.testCaseStorage[testCaseId];\n\n    // Look for the TestStep that was executed\n    const testStepOptions: TestStep[] = testCase.testSteps.filter(\n      s => s.id == event.testStepId\n    );\n    if (testStepOptions && testStepOptions.length != 1) {\n      throw new Error('Could not find test step within the test case');\n    }\n\n    // Now that we have the test step, lets look it up in the pickle to get the actual step text\n    const pickle: Pickle | undefined = this.pickleMap[testCase.pickleId];\n    const pickleStepId: string | undefined = testStepOptions[0].pickleStepId;\n    const pickleSteps: readonly PickleStep[] = pickle ? pickle.steps : [];\n    const pickleStep: PickleStep | undefined = pickleSteps.filter(\n      step => step.id == pickleStepId\n    )[0];\n\n    const stepText: string | undefined = pickleStep\n      ? pickleStep.text\n      : undefined;\n\n    // Map the step status to a result status\n    let status: TestResultStatus;\n    switch (event.testStepResult.status) {\n      case TestStepResultStatus.FAILED:\n        status = TestResultStatus.FAILED;\n        break;\n      case TestStepResultStatus.AMBIGUOUS:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.PENDING:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.SKIPPED:\n        status = TestResultStatus.SKIPPED;\n        break;\n      case TestStepResultStatus.UNDEFINED:\n        status = TestResultStatus.ERROR;\n        break;\n      case TestStepResultStatus.UNKNOWN:\n        status = TestResultStatus.FAILED;\n        break;\n    }\n    const cucumberMessage = this.cleanCucumberMessage(\n      event.testStepResult.message || 'Unknown'\n    );\n    let errorMessage: string;\n    if (stepText != undefined) {\n      errorMessage = `${event.testStepResult.status} Test Step: ${stepText}. Reason: ${cucumberMessage}`;\n    } else {\n      errorMessage = `Test Case ${event.testStepResult.status} at Unknown Step. Reason: ${cucumberMessage}`;\n    }\n    // Finally, save off the updated statuses\n    this.testResultStatusMap[event.testCaseStartedId] = [status, errorMessage];\n  }\n\n  /**\n   * Hook called when a TestCase finishes it's execution. USed to submit test results to AutoApi\n   *\n   * @param event The TestCaseFinished event\n   */\n  async onTestCaseFinished(event: TestCaseFinished): Promise<void> {\n    // Wait for the test result to be created before starting the result submission\n    const resultId = await this.testCaseInstanceResultIdMap[\n      event.testCaseStartedId\n    ];\n    // Pull the TestResults from the TestResultStatusMap\n    const [status, failure] = this.testResultStatusMap[event.testCaseStartedId];\n\n    // Finally, submit the TestResult\n    void (await this.autoApi.submitTestResult(\n      resultId,\n      status || TestResultStatus.PASSED,\n      failure\n    ));\n  }\n\n  private cleanCucumberMessage(message: string): string {\n    return message\n      .replace(this.REMOVE_ANSI_CHARACTERS, '')\n      .replace(this.REMOVE_CONTROL_CHARS, '');\n  }\n}\n"],"names":["CucumberAutoApiFormatter","Formatter","constructor","options","super","this","RegExp","join","apiKey","parsedArgvOptions","autoApiUrl","runName","productId","undefined","length","Error","autoApi","AutoApi","clientConfig","baseUrl","groupingName","registerListeners","eventBroadcaster","on","envelope","testCase","onTestCasePrepared","pickle","pickleMap","id","testCaseStarted","onTestCaseStarted","testStepFinished","onTestStepFinished","testCaseFinished","onTestCaseFinished","event","testCaseStorage","testCaseInstanceMap","testCaseId","testCaseInstanceResultIdMap","startTestCase","pickleId","name","then","res","data","testResultId","testResultStatusMap","TestResultStatus","PASSED","testStepResult","status","TestStepResultStatus","testCaseStartedId","testStepOptions","testSteps","filter","s","testStepId","pickleStepId","pickleStep","steps","step","stepText","text","FAILED","AMBIGUOUS","PENDING","ERROR","SKIPPED","UNDEFINED","UNKNOWN","cucumberMessage","cleanCucumberMessage","message","errorMessage","async","resultId","failure","submitTestResult","replace","REMOVE_ANSI_CHARACTERS","REMOVE_CONTROL_CHARS"],"mappings":"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"}