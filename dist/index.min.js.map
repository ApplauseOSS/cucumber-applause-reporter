{"version":3,"file":"index.min.js","sources":["../src/index.ts"],"sourcesContent":["import { Formatter } from '@cucumber/cucumber';\nimport { ApplauseReporter, TestResultStatus, loadConfig, } from 'applause-reporter-common';\nimport { TestStepResultStatus, } from '@cucumber/messages';\nexport default class CucumberAutoApiFormatter extends Formatter {\n    constructor(options) {\n        super(options);\n        // Maps used to handle data lookup between events.\n        // Test Case Storage Handles Storing Information about a TestCase by the TestCaseId\n        this.testCaseStorage = {};\n        // Test Case Instance Map Maps a TestCaseInstance Id (Single Execution of a TestCase) to the TestCaseId\n        this.testCaseInstanceMap = {};\n        // Pickle Map Holds Information about the Gherkin TestCase Information (The actual written out test case)\n        this.pickleMap = {};\n        // TestResult Status Map keeps track of the status for a TestCaseInstance. If a step fails, the test case fails\n        this.testResultStatusMap = {};\n        this.REMOVE_CONTROL_CHARS = new RegExp(\n        /* eslint-disable-next-line no-control-regex */\n        /[^\\x00-\\x7F]/gm);\n        this.REMOVE_ANSI_CHARACTERS = new RegExp(\n        /* eslint-disable-next-line no-control-regex */\n        [\n            '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n            '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n        ].join('|'), 'gm');\n        const config = loadConfig({\n            properties: {\n                apiKey: options.parsedArgvOptions['apiKey'],\n                baseUrl: options.parsedArgvOptions['autoApiUrl'],\n                productId: options.parsedArgvOptions['productId'],\n                testRailOptions: (options.parsedArgvOptions['testRailOptions']),\n                applauseTestCycleId: (options.parsedArgvOptions['applauseTestCycleId']),\n            },\n        });\n        // Setup our Http Client\n        this.reporter = new ApplauseReporter(config);\n        // Add in listener hooks\n        this.registerListeners(options.eventBroadcaster);\n    }\n    /**\n     * Registering an event listener to Cucumber's Messaging Api. Only one event will\n     * be contained in each envelope\n     *\n     * @param eventBroadcaster An Event Emitter\n     */\n    registerListeners(eventBroadcaster) {\n        eventBroadcaster.on('envelope', (envelope) => {\n            if (envelope.gherkinDocument) {\n                envelope.gherkinDocument.feature?.children.map(child => child.scenario?.name);\n            }\n            if (envelope.testRunStarted) {\n                this.reporter.runnerStart();\n            }\n            else if (envelope.testCase) {\n                this.onTestCasePrepared(envelope.testCase);\n            }\n            else if (envelope.pickle) {\n                this.pickleMap[envelope.pickle.id] = envelope.pickle;\n            }\n            else if (envelope.testCaseStarted) {\n                this.onTestCaseStarted(envelope.testCaseStarted);\n            }\n            else if (envelope.testStepFinished) {\n                this.onTestStepFinished(envelope.testStepFinished);\n            }\n            else if (envelope.testCaseFinished) {\n                void this.onTestCaseFinished(envelope.testCaseFinished);\n            }\n            else if (envelope.testRunFinished) {\n                void this.reporter.runnerEnd();\n            }\n        });\n    }\n    /**\n     * Hook called when a test case is parsed. Used for storing information about a TestCase\n     *\n     * @param event The Test Case Event\n     */\n    onTestCasePrepared(event) {\n        this.testCaseStorage[event.id] = event;\n    }\n    /**\n     * Hook called when a single instance of a test case is started. Used to register the start of a TestCase\n     *\n     * @param event The Test Case Started Event\n     */\n    onTestCaseStarted(event) {\n        this.testCaseInstanceMap[event.id] = event.testCaseId;\n        const testCase = this.testCaseStorage[event.testCaseId];\n        this.reporter.startTestCase(testCase.id, this.pickleMap[testCase.pickleId].name);\n        this.testResultStatusMap[event.id] = [TestResultStatus.PASSED, undefined];\n    }\n    /**\n     * Hook called when a TestStep is finished. Used to tell if and when a TestCase fails.\n     *\n     * @param event The Test Step Finished Event\n     */\n    onTestStepFinished(event) {\n        // We already assume that the test case will pass, so if it did, just move on\n        if (event.testStepResult.status == TestStepResultStatus.PASSED) {\n            return;\n        }\n        const currentStatus = this.testResultStatusMap[event.testCaseStartedId][0];\n        // If the current result already has a status set, don't override it\n        if (currentStatus != TestResultStatus.PASSED) {\n            return;\n        }\n        // Get the test case ID\n        const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n        // Lookup the TestCase\n        const testCase = this.testCaseStorage[testCaseId];\n        // Look for the TestStep that was executed\n        const testStepOptions = testCase.testSteps.filter(s => s.id == event.testStepId);\n        if (testStepOptions && testStepOptions.length != 1) {\n            throw new Error('Could not find test step within the test case');\n        }\n        // Now that we have the test step, lets look it up in the pickle to get the actual step text\n        const pickle = this.pickleMap[testCase.pickleId];\n        const pickleStepId = testStepOptions[0].pickleStepId;\n        const pickleSteps = pickle ? pickle.steps : [];\n        const pickleStep = pickleSteps.filter(step => step.id == pickleStepId)[0];\n        const stepText = pickleStep\n            ? pickleStep.text\n            : undefined;\n        // Map the step status to a result status\n        let status;\n        switch (event.testStepResult.status) {\n            case TestStepResultStatus.FAILED:\n                status = TestResultStatus.FAILED;\n                break;\n            case TestStepResultStatus.AMBIGUOUS:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.PENDING:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.SKIPPED:\n                status = TestResultStatus.SKIPPED;\n                break;\n            case TestStepResultStatus.UNDEFINED:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.UNKNOWN:\n                status = TestResultStatus.FAILED;\n                break;\n        }\n        const cucumberMessage = this.cleanCucumberMessage(event.testStepResult.message || 'Unknown');\n        let errorMessage;\n        if (stepText != undefined) {\n            errorMessage = `${event.testStepResult.status} Test Step: ${stepText}. Reason: ${cucumberMessage}`;\n        }\n        else {\n            errorMessage = `Test Case ${event.testStepResult.status} at Unknown Step. Reason: ${cucumberMessage}`;\n        }\n        // Finally, save off the updated statuses\n        this.testResultStatusMap[event.testCaseStartedId] = [status, errorMessage];\n    }\n    /**\n     * Hook called when a TestCase finishes it's execution. USed to submit test results to AutoApi\n     *\n     * @param event The TestCaseFinished event\n     */\n    onTestCaseFinished(event) {\n        // Pull the TestResults from the TestResultStatusMap\n        const [status, failure] = this.testResultStatusMap[event.testCaseStartedId];\n        const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n        // Finally, submit the TestResult\n        this.reporter.submitTestCaseResult(testCaseId, status || TestResultStatus.PASSED, { failureReason: failure });\n    }\n    cleanCucumberMessage(message) {\n        return message\n            .replace(this.REMOVE_ANSI_CHARACTERS, '')\n            .replace(this.REMOVE_CONTROL_CHARS, '');\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["CucumberAutoApiFormatter","Formatter","constructor","options","super","this","testCaseStorage","testCaseInstanceMap","pickleMap","testResultStatusMap","REMOVE_CONTROL_CHARS","RegExp","REMOVE_ANSI_CHARACTERS","join","config","loadConfig","properties","apiKey","parsedArgvOptions","baseUrl","productId","testRailOptions","applauseTestCycleId","reporter","ApplauseReporter","registerListeners","eventBroadcaster","on","envelope","gherkinDocument","feature","children","map","child","scenario","name","testRunStarted","runnerStart","testCase","onTestCasePrepared","pickle","id","testCaseStarted","onTestCaseStarted","testStepFinished","onTestStepFinished","testCaseFinished","onTestCaseFinished","testRunFinished","runnerEnd","event","testCaseId","startTestCase","pickleId","TestResultStatus","PASSED","undefined","testStepResult","status","TestStepResultStatus","testCaseStartedId","testStepOptions","testSteps","filter","s","testStepId","length","Error","pickleStepId","pickleStep","steps","step","stepText","text","FAILED","AMBIGUOUS","PENDING","ERROR","SKIPPED","UNDEFINED","UNKNOWN","cucumberMessage","cleanCucumberMessage","message","errorMessage","failure","submitTestCaseResult","failureReason","replace"],"mappings":"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"}