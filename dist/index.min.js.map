{"version":3,"file":"index.min.js","sources":["../src/hooks.ts","../src/index.ts"],"sourcesContent":["export const APPLAUSE_SESSION_ID_ATTACHMENT = 'applause-session-id';\nexport function linkSessionId(sessionId) {\n    this.attach(sessionId, {\n        fileName: APPLAUSE_SESSION_ID_ATTACHMENT,\n        mediaType: 'text/plain',\n    });\n}\n//# sourceMappingURL=hooks.js.map","import { Formatter } from '@cucumber/cucumber';\nimport { ApplauseReporter, TestResultStatus, loadConfig, } from 'applause-reporter-common';\nimport { TestStepResultStatus, } from '@cucumber/messages';\nimport { APPLAUSE_SESSION_ID_ATTACHMENT } from './hooks';\nexport default class CucumberAutoApiFormatter extends Formatter {\n    constructor(options) {\n        super(options);\n        // Maps used to handle data lookup between events.\n        // Test Case Storage Handles Storing Information about a TestCase by the TestCaseId\n        this.testCaseStorage = {};\n        // Test Case Instance Map Maps a TestCaseInstance Id (Single Execution of a TestCase) to the TestCaseId\n        this.testCaseInstanceMap = {};\n        this.testCaseInstanceSessionMap = {};\n        // Pickle Map Holds Information about the Gherkin TestCase Information (The actual written out test case)\n        this.pickleMap = {};\n        // TestResult Status Map keeps track of the status for a TestCaseInstance. If a step fails, the test case fails\n        this.testResultStatusMap = {};\n        this.REMOVE_CONTROL_CHARS = new RegExp(\n        /* eslint-disable-next-line no-control-regex */\n        /[^\\x00-\\x7F]/gm);\n        this.REMOVE_ANSI_CHARACTERS = new RegExp(\n        /* eslint-disable-next-line no-control-regex */\n        [\n            '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n            '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))',\n        ].join('|'), 'gm');\n        console.log('CDP is: ' + process.cwd());\n        const config = loadConfig({\n            configFile: 'applause.json',\n            properties: {\n                apiKey: options.parsedArgvOptions['apiKey'],\n                baseUrl: options.parsedArgvOptions['autoApiUrl'],\n                productId: options.parsedArgvOptions['productId'],\n                testRailOptions: (options.parsedArgvOptions['testRailOptions']),\n                applauseTestCycleId: (options.parsedArgvOptions['applauseTestCycleId']),\n            },\n        });\n        // Setup our Http Client\n        this.reporter = new ApplauseReporter(config);\n        // Add in listener hooks\n        this.registerListeners(options.eventBroadcaster);\n    }\n    /**\n     * Registering an event listener to Cucumber's Messaging Api. Only one event will\n     * be contained in each envelope\n     *\n     * @param eventBroadcaster An Event Emitter\n     */\n    registerListeners(eventBroadcaster) {\n        eventBroadcaster.on('envelope', (envelope) => {\n            if (envelope.gherkinDocument) {\n                envelope.gherkinDocument.feature?.children.map(child => child.scenario?.name);\n            }\n            if (envelope.testRunStarted) {\n                this.reporter.runnerStart(Object.values(this.testCaseStorage).map(testCase => this.pickleMap[testCase.pickleId].name));\n            }\n            else if (envelope.attachment) {\n                if (envelope.attachment.fileName == APPLAUSE_SESSION_ID_ATTACHMENT) {\n                    const testCaseStartedId = envelope.attachment.testCaseStartedId;\n                    if (testCaseStartedId === undefined) {\n                        return;\n                    }\n                    const existingSessions = this.testCaseInstanceSessionMap[testCaseStartedId] || [];\n                    this.testCaseInstanceSessionMap[testCaseStartedId] = [\n                        ...existingSessions,\n                        envelope.attachment.body,\n                    ];\n                }\n            }\n            else if (envelope.testCase) {\n                this.testCaseStorage[envelope.testCase.id] = envelope.testCase;\n            }\n            else if (envelope.pickle) {\n                this.pickleMap[envelope.pickle.id] = envelope.pickle;\n            }\n            else if (envelope.testCaseStarted) {\n                this.onTestCaseStarted(envelope.testCaseStarted);\n            }\n            else if (envelope.testStepFinished) {\n                this.onTestStepFinished(envelope.testStepFinished);\n            }\n            else if (envelope.testCaseFinished) {\n                void this.onTestCaseFinished(envelope.testCaseFinished);\n            }\n            else if (envelope.testRunFinished) {\n                void this.reporter.runnerEnd();\n            }\n        });\n    }\n    /**\n     * Hook called when a single instance of a test case is started. Used to register the start of a TestCase\n     *\n     * @param event The Test Case Started Event\n     */\n    onTestCaseStarted(event) {\n        this.testCaseInstanceMap[event.id] = event.testCaseId;\n        const testCase = this.testCaseStorage[event.testCaseId];\n        this.reporter.startTestCase(testCase.id, this.pickleMap[testCase.pickleId].name, { providerSessionIds: this.testCaseInstanceSessionMap[event.id] || [] });\n        this.testResultStatusMap[event.id] = [TestResultStatus.PASSED, undefined];\n    }\n    /**\n     * Hook called when a TestStep is finished. Used to tell if and when a TestCase fails.\n     *\n     * @param event The Test Step Finished Event\n     */\n    onTestStepFinished(event) {\n        // We already assume that the test case will pass, so if it did, just move on\n        if (event.testStepResult.status == TestStepResultStatus.PASSED) {\n            return;\n        }\n        const currentStatus = this.testResultStatusMap[event.testCaseStartedId][0];\n        // If the current result already has a status set, don't override it\n        if (currentStatus != TestResultStatus.PASSED) {\n            return;\n        }\n        // Get the test case ID\n        const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n        // Lookup the TestCase\n        const testCase = this.testCaseStorage[testCaseId];\n        // Look for the TestStep that was executed\n        const testStepOptions = testCase.testSteps.filter(s => s.id == event.testStepId);\n        if (testStepOptions && testStepOptions.length != 1) {\n            throw new Error('Could not find test step within the test case');\n        }\n        // Now that we have the test step, lets look it up in the pickle to get the actual step text\n        const pickle = this.pickleMap[testCase.pickleId];\n        const pickleStepId = testStepOptions[0].pickleStepId;\n        const pickleSteps = pickle ? pickle.steps : [];\n        const pickleStep = pickleSteps.filter(step => step.id == pickleStepId)[0];\n        const stepText = pickleStep\n            ? pickleStep.text\n            : undefined;\n        // Map the step status to a result status\n        let status;\n        switch (event.testStepResult.status) {\n            case TestStepResultStatus.FAILED:\n                status = TestResultStatus.FAILED;\n                break;\n            case TestStepResultStatus.AMBIGUOUS:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.PENDING:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.SKIPPED:\n                status = TestResultStatus.SKIPPED;\n                break;\n            case TestStepResultStatus.UNDEFINED:\n                status = TestResultStatus.ERROR;\n                break;\n            case TestStepResultStatus.UNKNOWN:\n                status = TestResultStatus.FAILED;\n                break;\n        }\n        const cucumberMessage = this.cleanCucumberMessage(event.testStepResult.message || 'Unknown');\n        let errorMessage;\n        if (stepText != undefined) {\n            errorMessage = `${event.testStepResult.status} Test Step: ${stepText}. Reason: ${cucumberMessage}`;\n        }\n        else {\n            errorMessage = `Test Case ${event.testStepResult.status} at Unknown Step. Reason: ${cucumberMessage}`;\n        }\n        // Finally, save off the updated statuses\n        this.testResultStatusMap[event.testCaseStartedId] = [status, errorMessage];\n    }\n    /**\n     * Hook called when a TestCase finishes it's execution. USed to submit test results to AutoApi\n     *\n     * @param event The TestCaseFinished event\n     */\n    onTestCaseFinished(event) {\n        // Pull the TestResults from the TestResultStatusMap\n        const [status, failure] = this.testResultStatusMap[event.testCaseStartedId];\n        const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n        // Finally, submit the TestResult\n        this.reporter.submitTestCaseResult(testCaseId, status || TestResultStatus.PASSED, {\n            failureReason: failure,\n            providerSessionGuids: this.testCaseInstanceSessionMap[event.testCaseStartedId] || [],\n        });\n    }\n    cleanCucumberMessage(message) {\n        return message\n            .replace(this.REMOVE_ANSI_CHARACTERS, '')\n            .replace(this.REMOVE_CONTROL_CHARS, '');\n    }\n}\nexport * from './hooks.ts';\n//# sourceMappingURL=index.js.map"],"names":["APPLAUSE_SESSION_ID_ATTACHMENT","CucumberAutoApiFormatter","Formatter","constructor","options","super","this","testCaseStorage","testCaseInstanceMap","testCaseInstanceSessionMap","pickleMap","testResultStatusMap","REMOVE_CONTROL_CHARS","RegExp","REMOVE_ANSI_CHARACTERS","join","console","log","process","cwd","config","loadConfig","configFile","properties","apiKey","parsedArgvOptions","baseUrl","productId","testRailOptions","applauseTestCycleId","reporter","ApplauseReporter","registerListeners","eventBroadcaster","on","envelope","gherkinDocument","feature","children","map","child","scenario","name","testRunStarted","runnerStart","Object","values","testCase","pickleId","attachment","fileName","testCaseStartedId","undefined","existingSessions","body","id","pickle","testCaseStarted","onTestCaseStarted","testStepFinished","onTestStepFinished","testCaseFinished","onTestCaseFinished","testRunFinished","runnerEnd","event","testCaseId","startTestCase","providerSessionIds","TestResultStatus","PASSED","testStepResult","status","TestStepResultStatus","testStepOptions","testSteps","filter","s","testStepId","length","Error","pickleStepId","pickleStep","steps","step","stepText","text","FAILED","AMBIGUOUS","PENDING","ERROR","SKIPPED","UNDEFINED","UNKNOWN","cucumberMessage","cleanCucumberMessage","message","errorMessage","failure","submitTestCaseResult","failureReason","providerSessionGuids","replace","sessionId","attach","mediaType"],"mappings":"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"}