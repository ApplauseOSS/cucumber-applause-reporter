{"version":3,"file":"index.min.js","sources":["../src/reporter.ts"],"sourcesContent":["import { Formatter, IFormatterOptions } from '@cucumber/cucumber';\nimport { AutoApi, TestResultStatus } from 'auto-api-client-js';\nimport { EventEmitter } from 'events';\nimport {\n  Envelope,\n  Pickle,\n  TestCase,\n  TestCaseFinished,\n  TestCaseStarted,\n  TestStepFinished,\n  TestStepResultStatus,\n} from '@cucumber/messages';\n\nexport default class CucumberAutoApiFormatter extends Formatter {\n  private autoApi: AutoApi;\n\n  // Custom Parameters\n  private productId: number;\n  private runName: string;\n\n  // Maps used to handle data lookup between events.\n  // Test Case Storage Handles Storing Information about a TestCase by the TestCaseId\n  private testCaseStorage: { [testCaseId: string]: TestCase } = {};\n  // Test Case Instance Map Maps a TestCaseInstance Id (Single Execution of a TestCase) to the TestCaseId\n  private testCaseInstanceMap: { [testCaseInstanceId: string]: string } = {};\n  // Test Instance ResultId Map Holds References to the TestResult creation promise\n  private testCaseInstanceResultIdMap: {\n    [testCaseInstanceId: string]: Promise<number>;\n  } = {};\n  // Pickle Map Holds Information about the Gherkin TestCase Information (The actual written out test case)\n  private pickleMap: { [pickleId: string]: Pickle } = {};\n  // TestResult Status Map keeps track of the status for a TestCaseInstance. If a step fails, the test case fails\n  private testResultStatusMap: {\n    [testCaseInstanceId: string]: [TestResultStatus, string | undefined];\n  } = {};\n\n  constructor(options: IFormatterOptions) {\n    super(options);\n\n    // Extract out any arguments and handle validation\n    const apiKey = <string>options.parsedArgvOptions['apiKey'];\n    const autoApiUrl = <string>options.parsedArgvOptions['autoApiUrl'];\n    this.runName = <string>options.parsedArgvOptions['runName'];\n    this.productId = <number>options.parsedArgvOptions['productId'];\n    if (apiKey == undefined || apiKey.length <= 0) {\n      throw new Error('Invalid Api Key');\n    } else if (this.runName == undefined || this.runName.length <= 0) {\n      throw new Error('Invalid Run Name: ' + this.runName);\n    } else if (this.productId < 0) {\n      throw new Error(`Invalid Product Id: ${this.productId}`);\n    } else if (autoApiUrl == undefined || autoApiUrl.length <= 0) {\n      throw new Error('Invalid URL: ' + autoApiUrl);\n    }\n\n    // Setup our Http Client\n    this.autoApi = new AutoApi({\n      clientConfig: {\n        apiKey,\n        baseUrl: autoApiUrl,\n      },\n      productId: this.productId,\n      groupingName: this.runName,\n    });\n\n    // Add in listener hooks\n    this.registerListeners(options.eventBroadcaster);\n  }\n\n  /**\n   * Registering an event listener to Cucumber's Messaging Api. Only one event will\n   * be contained in each envelope\n   *\n   * @param eventBroadcaster An Event Emitter\n   */\n  registerListeners(eventBroadcaster: EventEmitter): void {\n    eventBroadcaster.on('envelope', (envelope: Envelope) => {\n      if (envelope.testCase) {\n        this.onTestCasePrepared(envelope.testCase);\n      } else if (envelope.pickle) {\n        this.pickleMap[envelope.pickle.id] = envelope.pickle;\n      } else if (envelope.testCaseStarted) {\n        this.onTestCaseStarted(envelope.testCaseStarted);\n      } else if (envelope.testStepFinished) {\n        this.onTestStepFinished(envelope.testStepFinished);\n      } else if (envelope.testCaseFinished) {\n        void this.onTestCaseFinished(envelope.testCaseFinished);\n      }\n    });\n  }\n\n  /**\n   * Hook called when a test case is parsed. Used for storing information about a TestCase\n   *\n   * @param event The Test Case Event\n   */\n  onTestCasePrepared(event: TestCase): void {\n    this.testCaseStorage[event.id] = event;\n  }\n\n  /**\n   * Hook called when a single instance of a test case is started. Used to register the start of a TestCase\n   *\n   * @param event The Test Case Started Event\n   */\n  onTestCaseStarted(event: TestCaseStarted): void {\n    this.testCaseInstanceMap[event.id] = event.testCaseId;\n    const testCase = this.testCaseStorage[event.testCaseId];\n    // These messages happen async from the execution of the test cases. That means that we need\n    this.testCaseInstanceResultIdMap[event.id] = this.autoApi\n      .startTestCase(this.pickleMap[testCase.pickleId].name)\n      .then(res => res.data.testResultId);\n    this.testResultStatusMap[event.id] = [TestResultStatus.PASSED, undefined];\n  }\n\n  /**\n   * Hook called when a TestStep is finished. Used to tell if and when a TestCase fails.\n   *\n   * @param event The Test Step Finished Event\n   */\n  onTestStepFinished(event: TestStepFinished): void {\n    // We already assume that the test case will pass, so if it did, just move on\n    if (event.testStepResult.status == TestStepResultStatus.PASSED) {\n      return;\n    }\n\n    const currentStatus = this.testResultStatusMap[event.testCaseStartedId][0];\n    // If the current result already has a status set, don't override it\n    if (currentStatus != TestResultStatus.PASSED) {\n      return;\n    }\n\n    // Get the test case ID\n    const testCaseId = this.testCaseInstanceMap[event.testCaseStartedId];\n\n    // Lookup the TestCase\n    const testCase = this.testCaseStorage[testCaseId];\n\n    // Look for the TestStep that was executed\n    const testStepOptions = testCase.testSteps.filter(\n      s => s?.id == event.testStepId\n    );\n    if (testStepOptions && testStepOptions.length != 1) {\n      throw new Error('Could not find test step within the test case');\n    }\n\n    // Now that we have the test step, lets look it up in the pickle to get the actual step text\n    const pickle = this.pickleMap[testCase.pickleId];\n    const pickleStepId = testStepOptions[0].pickleStepId;\n    const pickleStep = pickle.steps.filter(step => step.id == pickleStepId)[0];\n\n    // Map the step status to a result status\n    let result: [TestResultStatus, string | undefined];\n    switch (event.testStepResult.status) {\n      case TestStepResultStatus.FAILED:\n        result = [\n          TestResultStatus.FAILED,\n          'Test Failed at Step: ' + pickleStep.text,\n        ];\n        break;\n      case TestStepResultStatus.AMBIGUOUS:\n        result = [\n          TestResultStatus.ERROR,\n          'Ambiguous Test Step Status at Step: ' + pickleStep.text,\n        ];\n        break;\n      case TestStepResultStatus.PENDING:\n        result = [\n          TestResultStatus.ERROR,\n          'Pending TestStep Status at Step: ' + pickleStep.text,\n        ];\n        break;\n      case TestStepResultStatus.SKIPPED:\n        result = [\n          TestResultStatus.SKIPPED,\n          'Test Skipped at Step: ' + pickleStep.text,\n        ];\n        break;\n      case TestStepResultStatus.UNDEFINED:\n        result = [\n          TestResultStatus.ERROR,\n          'Undefined Test Step Status at Step: ' + pickleStep.text,\n        ];\n        break;\n      case TestStepResultStatus.UNKNOWN:\n        result = [\n          TestResultStatus.FAILED,\n          'Unknown Test Step Status at Step: ' + pickleStep.text,\n        ];\n        break;\n    }\n\n    // Finally, save off the updated statuses\n    this.testResultStatusMap[event.testCaseStartedId] = result;\n  }\n\n  /**\n   * Hook called when a TestCase finishes it's execution. USed to submit test results to AutoApi\n   *\n   * @param event The TestCaseFinished event\n   */\n  async onTestCaseFinished(event: TestCaseFinished): Promise<void> {\n    // Wait for the test result to be created before starting the result submission\n    const resultId = await this.testCaseInstanceResultIdMap[\n      event.testCaseStartedId\n    ];\n    // Pull the TestResults from the TestResultStatusMap\n    const [status, failure] = this.testResultStatusMap[event.testCaseStartedId];\n\n    // Finally, submit the TestResult\n    void (await this.autoApi.submitTestResult(\n      resultId,\n      status || TestResultStatus.PASSED,\n      failure\n    ));\n  }\n}\n"],"names":["CucumberAutoApiFormatter","Formatter","constructor","options","super","this","apiKey","parsedArgvOptions","autoApiUrl","runName","productId","undefined","length","Error","autoApi","AutoApi","clientConfig","baseUrl","groupingName","registerListeners","eventBroadcaster","on","envelope","testCase","onTestCasePrepared","pickle","pickleMap","id","testCaseStarted","onTestCaseStarted","testStepFinished","onTestStepFinished","testCaseFinished","onTestCaseFinished","event","testCaseStorage","testCaseInstanceMap","testCaseId","testCaseInstanceResultIdMap","startTestCase","pickleId","name","then","res","data","testResultId","testResultStatusMap","TestResultStatus","PASSED","testStepResult","status","TestStepResultStatus","testCaseStartedId","testStepOptions","testSteps","filter","s","testStepId","pickleStepId","pickleStep","steps","step","result","FAILED","text","AMBIGUOUS","ERROR","PENDING","SKIPPED","UNDEFINED","UNKNOWN","async","resultId","failure","submitTestResult"],"mappings":"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"}